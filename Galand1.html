<!-- Save as Galand1-updated.html or paste into JSFiddle (HTML panel) -->
<div id="menu">
  <h1>Galactica Ultra</h1>
  <p>Select Difficulty:</p>
  <button id="easyBtn">Easy</button>
  <button id="normalBtn">Normal</button>
  <button id="hardBtn">Hard</button>
  <div style="margin-top:18px; font-size:14px; color:#ddd; max-width:560px; margin-left:auto; margin-right:auto;">
    Tip: Use Arrow keys (← →) to move. Space to shoot. B to drop a bomb.
  </div>
</div>

<div id="instructions" style="text-align:center; display:none; margin-top:8px;">
  <h2 style="margin:6px 0 2px 0; font-size:18px;">How to Play</h2>
  <p style="margin:0 12px 8px 12px; color:#ddd; font-size:14px;">
    Destroy enemy waves. Collect <span style="color:#ff6666">+ health</span> to heal, collect <span style="color:#ffd700">gun</span> upgrades to power up your weapons,
    and <span style="color:#66ffff">shields</span> to temporarily block damage. Survive and defeat the boss to win!
  </p>
</div>

<div id="gameArea" style="display:none;">
  <canvas id="gameCanvas" width="600" height="700"></canvas>
</div>

<style>
  body { margin:0; background:black; overflow:hidden; font-family:Arial; color:white; }
  #menu { text-align:center; margin-top:80px; }
  button { padding:10px 20px; margin:10px; font-size:18px; cursor:pointer; }
  #gameArea { display:flex; justify-content:center; margin-top:10px; }
  canvas { background:black; border:2px solid #444; box-shadow:0 0 20px #0ff; image-rendering: pixelated; }
  .overlay {
    position:absolute; left:0; top:0; width:100%; height:100%; display:flex;
    align-items:center; justify-content:center; pointer-events:none;
  }
</style>

<script>
window.addEventListener('load', () => {

  /********************** PIXEL SPRITE GENERATOR (SNES-Style) **********************/
  function createPixelSprite(pixels, palette, scale=4){
    const w = pixels[0].length;
    const h = pixels.length;
    const c = document.createElement('canvas');
    c.width = w * scale;
    c.height = h * scale;
    const ctx = c.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const colIndex = pixels[y][x];
        if(colIndex === null) continue;
        ctx.fillStyle = palette[colIndex];
        ctx.fillRect(x*scale, y*scale, scale, scale);
      }
    }
    return c;
  }

  // palettes (SNES-y)
  const palettePlayer = ['#000000', '#00FFFF', '#006060', '#FFFFFF', '#FFD600', '#202020'];
  const paletteEnemy  = ['#000000', '#FF66FF', '#990066', '#FFFFFF', '#660033'];
  const paletteMini   = ['#000000', '#FFAA33', '#663300', '#FFFFFF'];
  const paletteBoss   = ['#000000', '#FF88FF', '#770044', '#FFDDFF', '#442244', '#FFFFFF'];
  const paletteExplosion = ['#000000','#FFB400','#FF3D00','#FFFFFF','#FF6A00'];

  // player/enemy pixel maps (from your original)
  const playerPixels1 = [
    [null,null,null,0,0,1,0,0,null,null,null],
    [null,null,0,0,1,1,1,0,0,null,null],
    [null,0,0,0,1,1,1,0,0,0,null],
    [0,0,0,1,1,1,1,1,0,0,0],
    [0,0,1,1,1,1,1,1,1,0,0],
    [0,1,1,1,1,1,1,1,1,1,0],
    [0,0,1,1,1,1,1,1,1,0,0],
    [null,0,0,1,1,1,1,1,0,0,null],
    [null,null,0,0,1,1,1,0,0,null,null],
    [null,null,null,0,0,1,0,0,null,null,null],
    [null,null,null,null,0,0,null,null,null,null,null]
  ];
  const playerPixels2 = [
    [null,null,null,0,0,1,0,0,null,null,null],
    [null,null,0,0,1,1,1,0,0,null,null],
    [null,0,0,0,1,1,1,0,0,0,null],
    [0,0,0,1,1,1,1,1,0,0,0],
    [0,0,1,1,1,1,1,1,1,0,0],
    [0,1,1,1,3,1,1,1,1,1,0],
    [0,0,1,1,1,1,1,1,1,0,0],
    [null,0,0,1,1,1,1,1,0,0,null],
    [null,null,0,0,1,1,1,0,0,null,null],
    [null,null,null,0,0,1,0,0,null,null,null],
    [null,null,null,null,0,0,null,null,null,null,null]
  ];
  const enemyPixels1 = [
    [null,0,0,0,0,0,0,0,0,null],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,1,1,1,1,1,1,0,0],
    [0,1,1,2,1,1,2,1,1,0],
    [0,1,1,2,2,2,2,1,1,0],
    [0,0,1,1,1,1,1,1,0,0],
    [null,0,0,1,1,1,1,0,0,null],
    [null,null,0,0,1,1,0,0,null,null]
  ];
  const enemyPixels2 = enemyPixels1.map(r=>r.slice());
  const miniPixels = [
    [null,0,0,0,0,0,0,0,0,0,null,null],
    [0,0,1,1,1,1,1,1,1,1,0,0],
    [0,1,1,2,1,1,1,1,2,1,1,0],
    [1,1,1,1,1,1,1,1,1,1,1,1],
    [1,1,3,1,1,4,4,1,1,3,1,1],
    [0,1,1,1,1,1,1,1,1,1,1,0],
    [null,0,1,1,1,1,1,1,1,1,0,null],
    [null,null,0,0,1,1,1,1,0,0,null,null]
  ];
  const bossPixels = [
    [null,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,null],
    [null,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,null],
    [0,1,1,2,2,2,2,3,3,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,1,1,0],
    [0,1,2,2,2,2,3,3,4,4,4,4,4,4,4,4,4,3,3,2,2,2,2,2,2,1,0],
    [0,1,2,3,3,4,4,4,4,4,4,5,5,4,4,4,4,4,4,3,3,2,2,2,1,1,0],
    [0,1,2,3,4,4,4,4,4,4,4,5,5,4,4,4,4,4,4,4,3,3,2,2,1,1,0],
    [0,1,2,3,4,4,4,4,4,4,4,5,5,4,4,4,4,4,4,4,4,3,3,2,1,1,0],
    [null,0,1,2,3,3,4,4,4,4,4,5,5,4,4,4,4,4,4,4,3,3,2,1,0,null,null],
    [null,null,0,1,1,2,3,3,3,3,3,4,4,3,3,3,3,3,3,3,2,1,0,null,null,null],
    [null,null,null,0,0,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,0,0,null,null,null,null],
    [null,null,null,null,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,null,null,null,null,null,null],
    [null,null,null,null,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,null,null,null,null,null,null]
  ];
  const explosionFramesPixels = [
    [
      [null,null,0,0,0,null],
      [null,0,1,1,0,null],
      [0,1,2,2,1,0],
      [0,1,2,2,1,0],
      [null,0,1,1,0,null],
      [null,null,0,0,0,null]
    ],
    [
      [null,0,1,1,0,null],
      [0,1,2,2,1,0],
      [1,2,3,3,2,1],
      [1,2,3,3,2,1],
      [0,1,2,2,1,0],
      [null,0,1,1,0,null]
    ],
    [
      [0,1,2,2,1,0],
      [1,2,3,3,2,1],
      [2,3,4,4,3,2],
      [2,3,4,4,3,2],
      [1,2,3,3,2,1],
      [0,1,2,2,1,0]
    ]
  ];

  const playerSpriteA = createPixelSprite(playerPixels1, palettePlayer, 4);
  const playerSpriteB = createPixelSprite(playerPixels2, palettePlayer, 4);
  const enemySpriteA  = createPixelSprite(enemyPixels1, paletteEnemy, 3);
  const enemySpriteB  = createPixelSprite(enemyPixels2, paletteEnemy, 3);
  const miniSprite    = createPixelSprite(miniPixels, paletteMini, 3);
  const bossSprite    = createPixelSprite(bossPixels, paletteBoss, 2);
  const explosionFrames = explosionFramesPixels.map(fr => createPixelSprite(fr, paletteExplosion, 6));

  /********************** AUDIO (WebAudio) **********************/
  const AudioCtx = window.AudioContext||window.webkitAudioContext;
  const audioCtx = new AudioCtx();

  // simple beep - softer gain (battleship-like short tone)
  function beep(freq,dur,type='square',volume=0.05){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.value = freq;
    o.type = type;
    g.gain.value = volume;
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(volume, now + 0.005);
    g.gain.linearRampToValueAtTime(0.0001, now + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now);
    o.stop(now + dur + 0.02);
  }
  const sndPlayerShoot = ()=>beep(900,0.06,'square',0.06);
  const sndEnemyShoot = ()=>beep(220,0.08,'sawtooth',0.04);
  const sndHit = ()=>beep(160,0.08,'triangle',0.04);
  const sndExplosion = ()=>beep(80,0.28,'sawtooth',0.08);
  const sndPickup = ()=>beep(1200,0.07,'sine',0.06);

  // create a subtle looping galaxy ambience (buffered noise + low hum)
  let ambienceNode = null;
  function startAmbience(){
    if(ambienceNode) return;
    const sr = audioCtx.sampleRate;
    const length = sr * 4;
    const noiseBuf = audioCtx.createBuffer(1, length, sr);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<length;i++){
      data[i] = (Math.random()*2-1) * 0.02 * Math.sin(i/1000);
    }
    const src = audioCtx.createBufferSource();
    src.buffer = noiseBuf;
    src.loop = true;
    const g = audioCtx.createGain();
    g.gain.value = 0.035;
    const hum = audioCtx.createOscillator();
    hum.frequency.value = 40;
    const humG = audioCtx.createGain();
    humG.gain.value = 0.005;
    hum.connect(humG);
    humG.connect(g);
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
    hum.start();
    ambienceNode = { src, hum, gain:g, humGain:humG };
  }
  function stopAmbience(){
    if(!ambienceNode) return;
    try { ambienceNode.src.stop(); ambienceNode.hum.stop(); } catch(e){}
    ambienceNode = null;
  }

  /********************** DIFFICULTY SETTINGS **********************/
  let DIFF={waveCount:6, enemyHP:200, miniHP:100, enemyRate:60, enemySpeed:2};

  // hook up buttons
  const easyBtn = document.getElementById('easyBtn');
  const normalBtn = document.getElementById('normalBtn');
  const hardBtn = document.getElementById('hardBtn');

  easyBtn.addEventListener('click', ()=>startGame('easy'));
  normalBtn.addEventListener('click', ()=>startGame('normal'));
  hardBtn.addEventListener('click', ()=>startGame('hard'));

  function startGame(d){
    if(d==='easy') DIFF={waveCount:4,enemyHP:180,miniHP:80,enemyRate:75,enemySpeed:1.5};
    if(d==='normal')DIFF={waveCount:6,enemyHP:200,miniHP:100,enemyRate:60,enemySpeed:2};
    if(d==='hard') DIFF={waveCount:8,enemyHP:250,miniHP:130,enemyRate:45,enemySpeed:3};
    const menu = document.getElementById('menu');
    const inst = document.getElementById('instructions');
    const gameArea = document.getElementById('gameArea');
    if(menu) menu.style.display='none';
    if(inst) inst.style.display='block';
    if(gameArea) gameArea.style.display='flex';
    if(audioCtx.state === 'suspended'){ audioCtx.resume().then(()=>startAmbience()); }
    else startAmbience();
    init(); gameLoop();
  }

  /********************** GAME VARIABLES (performance + upgrades) **********************/
  let canvas, ctx;
  let player;
  let bullets, enemyBullets;
  let waves, currentWave;
  let miniBosses;
  let boss;
  let pickups;
  let bombs=[];
  let shieldActive=false;
  let shieldTime=0;
  let gameRunning = false;
  let explosions = [];
  let lastEnemyFire = 0;
  let frameCount = 0;
  let showWin = false;

  // performance metrics
  let score = 0;
  let kills = 0;
  let shotsFired = 0;
  let hits = 0;
  let startTime = 0;
  let survivalTime = 0;

  // shooting cooldown
  const SHOOT_COOLDOWN_MS = 120;
  let lastShotTime = 0;

  // gun upgrade state (stacking)
  let gunLevel = 1; // 1 = base, increases with pickups
  let baseBulletDamage = 10;

  /********************** INIT **********************/
  function init(){
    canvas=document.getElementById('gameCanvas');
    if(!canvas) { console.error('Game canvas not found'); return; }
    ctx=canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    player = { x:280, y:620, w:44, h:44, speed:5, health:100, rapid:false, animFrame:0 };
    bullets=[]; enemyBullets=[]; pickups=[]; miniBosses=[]; bombs=[]; explosions=[];

    waves=createWaves(DIFF.waveCount);
    currentWave=0;

    boss=createBoss();
    gameRunning = true;
    showWin = false;
    frameCount = 0;

    // reset metrics and gun level
    score = 0; kills = 0; shotsFired = 0; hits = 0;
    startTime = Date.now();
    gunLevel = 1;
  }

  /********************** WAVES **********************/
  function createWaves(n){
    let arr=[];
    for(let w=0;w<n;w++){
      let wave=[];
      for(let i=0;i<6;i++) wave.push({x:30+i*90,y:-(w*220)-50,w:40,h:30,dy:2,hp:40,anim:Math.random()*10});
      arr.push(wave);
    }
    return arr;
  }

  /********************** BOSSES **********************/
  function createBoss(){
    return {
      x:200, y:20, w:bossSprite.width*1.2, h:bossSprite.height*1.2,
      health:DIFF.enemyHP, dir:1, fireCooldown:120, phase:0, phaseTimer:300, alive:true, frame:0
    };
  }

  /********************** INPUT **********************/
  let keys={};
  document.addEventListener('keydown',e=>{ keys[e.key]=true; if(e.key===' '||e.key==='Space') e.preventDefault(); });
  document.addEventListener('keyup',e=>{ keys[e.key]=false; });

  /********************** SHOOT (stacking spread, damage) **********************/
  function shoot(){
    if(!gameRunning) return;
    const now = Date.now();
    const cooldown = Math.max(40, SHOOT_COOLDOWN_MS - (gunLevel * 10));
    if(now - lastShotTime < cooldown) return;
    lastShotTime = now;

    // pattern: number of bullets equals gunLevel (capped to reasonable)
    const pattern = Math.min(5, gunLevel); // cap pattern at 5
    const spread = 0.18; // radians between bullets
    const centerX = player.x + player.w/2;
    const startAngle = -((pattern-1)/2) * spread;

    for(let i=0;i<pattern;i++){
      const angle = startAngle + i*spread;
      bullets.push({
        x: centerX - (4 + gunLevel/2),
        y: player.y - 8,
        w: 4 + Math.floor(gunLevel/1.2),
        h: 8 + Math.floor(gunLevel/1.1),
        dy: -10,
        dx: Math.sin(angle) * 3,
        damage: baseBulletDamage + gunLevel * 4
      });
      shotsFired++;
    }
    sndPlayerShoot();
  }

  function dropBomb(){ bombs.push({x:player.x+10,y:player.y,w:20,h:20,frame:0}); sndExplosion(); }

  /********************** EXPLOSIONS **********************/
  function spawnExplosion(x,y){
    explosions.push({x:x-12,y:y-12,frame:0,life:explosionFrames.length});
    sndExplosion();
  }
  function drawExplosion(b){ ctx.drawImage(explosionFrames[Math.floor(b.frame)], b.x, b.y); b.frame+=0.35; }

  /********************** UPDATE **********************/
  function update(){
    if(!gameRunning) return;
    frameCount++;

    if(keys['ArrowLeft']&&player.x>0)player.x-=player.speed;
    if(keys['ArrowRight']&&player.x+player.w<600)player.x+=player.speed;
    if(keys[' ']||keys['Space']) shoot();
    if(keys['b']||keys['B']) { if(bombs.length<2) dropBomb(); }

    // player animation frame
    player.animFrame = (Math.floor(frameCount/6) % 2);

    /********* SHIELD TIMER *********/
    if(shieldActive){ shieldTime--; if(shieldTime<=0)shieldActive=false; }

    /********* PLAYER BULLETS *********/
    bullets.forEach(b=>{ b.x += b.dx||0; b.y += b.dy; });
    bullets=bullets.filter(b=>b.y>-40 && !b.dead);

    /******** WAVES BEFORE BOSS ********/
    if(currentWave < waves.length){
      let wave = waves[currentWave];
      wave.forEach((e,i)=>{ e.y += e.dy + Math.sin((frameCount+e.anim)/30)*0.3; });
      // bullet collisions
      wave.forEach(enemy=>{
        bullets.forEach(b=>{
          if(rect(enemy,b)){
            enemy.hp = (enemy.hp||40) - (b.damage || 10);
            b.dead=true;
            hits++;
            sndHit();
            if((enemy.hp||40)<=0){
              spawnExplosion(enemy.x,enemy.y);
              sndExplosion();
              score += Math.floor(100 * getAccuracyMultiplier());
              kills += 1;
            }
          }
        });
      });
      wave = wave.filter(e=> (e.hp === undefined || e.hp>0) && e.y<700 );
      waves[currentWave]=wave;
      if(wave.length===0) currentWave++;
    }

    /******** MINI BOSSES ********/
    if(Math.random()<0.01 && currentWave>=waves.length)
      miniBosses.push({x:Math.random()*520,y:-60,w:miniSprite.width,h:miniSprite.height,dy:2,hp:DIFF.miniHP,fire:60});

    miniBosses.forEach(m=>{
      m.y+=m.dy; m.fire--;
      bullets.forEach(b=>{ if(rect(m,b)){ m.hp-= (b.damage || 10); b.dead=true; hits++; sndHit(); if(m.hp<=0){ spawnExplosion(m.x,m.y); sndExplosion(); score += Math.floor(400 * getAccuracyMultiplier()); kills += 1; } } });
      if(m.fire<=0){ enemyFire(m); m.fire = 60 + Math.floor(Math.random()*60); }
    });
    miniBosses=miniBosses.filter(m=>m.hp>0 && m.y<700);

    bullets=bullets.filter(b=>!b.dead);

    /******** ENEMY FIRE (random small enemies) ********/
    if(frameCount % Math.max(20, DIFF.enemyRate) === 0 && currentWave < waves.length){
      const wave = waves[currentWave];
      if(wave && wave.length>0){
        const shooter = wave[Math.floor(Math.random()*wave.length)];
        enemyFire(shooter);
      }
    }

    enemyBullets.forEach(b=>{b.x+=b.dx || 0; b.y+=b.dy || 0;});
    enemyBullets=enemyBullets.filter(b=>b.y<800 && !b.dead);

    /******** ENEMY HITS PLAYER ********/
    enemyBullets.forEach(b=>{
      if(rect(player,b) && !shieldActive){
        // laser hits are heavier
        player.health -= b.laser ? 20 : 10;
        b.dead=true;
        sndHit();
      }
    });
    enemyBullets=enemyBullets.filter(b=>!b.dead);

    /******** PICKUPS ********/
    if(Math.random()<0.005) pickups.push({x:Math.random()*560,y:-20,w:30,h:30,dy:2,type:randomPickup()});
    pickups.forEach(p=>{ p.y+=p.dy; if(rect(player,p)){ applyPickup(p.type); p.dead=true; sndPickup(); }});    
    pickups=pickups.filter(p=>!p.dead);

    /******** BOMBS ********/
    bombs.forEach(b=>b.frame+=0.4);
    bombs=bombs.filter(b=>b.frame<explosionFrames.length);

    /******** EXPLOSIONS ********/
    explosions.forEach(e=>{ if(e.frame >= e.life) e.dead = true; });
    explosions = explosions.filter(e=>!e.dead);

    /******** BOSS BEHAVIOR (multi-phase) ********/
    if(currentWave >= waves.length && boss.alive){
      if(boss.y < 40){
        boss.y += 1.5;
      } else {

        boss.phaseTimer--;
        if(boss.phaseTimer <= 0){
          boss.phase = (boss.phase + 1) % 3;
          boss.phaseTimer = 300;
        }

        boss.x += boss.dir * (DIFF.enemySpeed * 0.8);
        if(boss.x < 10 || boss.x + boss.w > 590) boss.dir *= -1;

        // Phase 0: Spread
        if(boss.phase === 0){
          boss.fireCooldown--;
          if(boss.fireCooldown <= 0){
            for(let i=-2;i<=2;i++){
              enemyBullets.push({
                x: boss.x + boss.w/2,
                y: boss.y + boss.h - 10,
                w: 8, h: 12,
                dx: i*1.5,
                dy: 3
              });
            }
            sndEnemyShoot();
            boss.fireCooldown = 60;
          }
        }

        // Phase 1: Laser sweep
        if(boss.phase === 1){
          // create a long vertical 'laser' bullet periodically
          if(frameCount % 12 === 0){
            // laser sweeps left-right by using boss.dir sign (rendered as translucent long rect)
            enemyBullets.push({
              x: boss.x + boss.w/2 - 4,
              y: boss.y + boss.h,
              w: 8,
              h: 700,
              dy: 2,
              dx: boss.dir * 0.6,
              laser: true
            });
            sndEnemyShoot();
          }
        }

        // Phase 2: Charge
        if(boss.phase === 2){
          if(boss.phaseTimer > 200){
            // wind-up (visual could be added)
          } else {
            // quick downward charge and recoil
            boss.y += 4;
            if(boss.y > 300) boss.y -= 6;
          }
        }

        // hits to boss
        bullets.forEach(b=>{
          if(rect(boss,b)){
            boss.health -= (b.damage || 10);
            b.dead = true;
            hits++;
            sndHit();
            if(boss.health <= 0){
              boss.alive = false;
              spawnExplosion(boss.x+boss.w/2, boss.y+boss.h/2);
              sndExplosion();
              score += Math.floor(2000 * getAccuracyMultiplier());
              kills++;
            }
          }
        });

      }
    }

    // check boss defeat -> win
    if(boss.alive === false && !showWin){
      showWin = true;
      gameRunning = false;
      setTimeout(()=>{ showEndOverlay(true); }, 150);
    }

    // game over
    if(player.health <= 0 && gameRunning){
      gameRunning = false;
      setTimeout(()=>{ showEndOverlay(false); }, 50);
    }

    // update survival time
    survivalTime = Math.floor((Date.now() - startTime) / 1000);
  }

  /********************** PICKUPS **********************/
  function randomPickup(){return ['shield','rapid','heal'][Math.floor(Math.random()*3)];}
  function applyPickup(t){
    if(t==='shield'){ shieldActive=true; shieldTime=300; }
    if(t==='rapid'){ 
      gunLevel++;                // stacking upgrade
      player.rapid=true; 
      setTimeout(()=>player.rapid=false,5000);
    }
    if(t==='heal'){ player.health=Math.min(100,player.health+30); }
  }

  /********************** COLLISION **********************/
  function rect(a,b){ return a && b && a.x < b.x + b.w && a.x + (a.w||20) > b.x && a.y < b.y + b.h && a.y + (a.h||20) > b.y; }

  /********************** ENEMY FIRE **********************/
  function enemyFire(ship){
    const angle = (Math.random()*40-20)*(Math.PI/180);
    enemyBullets.push({ x:ship.x + (ship.w||40)/2, y:ship.y + (ship.h||20), w:8,h:12, dx:Math.sin(angle)*3, dy:Math.cos(angle)*3+2 });
    sndEnemyShoot();
  }

  /********************** RENDER **********************/
  function render(){
    if(!ctx) return;
    ctx.clearRect(0,0,600,700);
    // soft scanline background for SNES feel
    ctx.fillStyle='rgba(0,8,20,0.4)'; ctx.fillRect(0,0,600,700);
    for(let y=0;y<700;y+=4){ ctx.fillStyle='rgba(255,255,255,0.002)'; ctx.fillRect(0,y,600,1); }

    // Player
    const pSprite = (player.animFrame === 0) ? playerSpriteA : playerSpriteB;
    ctx.drawImage(pSprite, player.x, player.y, player.w, player.h);
    if(shieldActive){ ctx.strokeStyle='rgba(0,255,255,0.6)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(player.x+player.w/2,player.y+player.h/2,36,0,Math.PI*2); ctx.stroke(); }

    // Waves (small enemies)
    if(currentWave < waves.length) waves[currentWave].forEach(e=>{
      const es = (Math.floor(frameCount/12)%2===0) ? enemySpriteA : enemySpriteB;
      ctx.drawImage(es, e.x, e.y, e.w, e.h);
    });

    // Mini-bosses
    miniBosses.forEach(m=>{ ctx.drawImage(miniSprite, m.x, m.y, m.w, m.h); });

    // Boss
    if(currentWave >= waves.length && boss.alive){
      ctx.drawImage(bossSprite, boss.x, boss.y, boss.w, boss.h);
      drawBossHP(80, 18, 440, 18, boss.health, DIFF.enemyHP);
      // small phase indicator
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.fillText(`Phase: ${boss.phase+1}`, 520, 50);
    }

    // Bullets (player)
    ctx.fillStyle='white';
    bullets.forEach(b=>{
      ctx.fillRect(Math.round(b.x), Math.round(b.y), Math.round(b.w), Math.round(b.h));
    });

    // Enemy bullets (normal)
    ctx.fillStyle='red';
    enemyBullets.forEach(b=>{
      if(b.laser){
        // drawn transparently below in laser draw
      } else {
        ctx.fillRect(Math.round(b.x), Math.round(b.y), Math.round(b.w), Math.round(b.h));
      }
    });

    // Draw lasers (translucent long rectangles)
    enemyBullets.forEach(b=>{
      if(b.laser){
        ctx.fillStyle = 'rgba(255,60,60,0.18)';
        ctx.fillRect(Math.round(b.x), Math.round(b.y), Math.round(b.w), Math.round(b.h));
      }
    });

    // Pickups (draw symbol per type)
    pickups.forEach(p=>{
      if(p.type === 'heal') drawHealthPickup(p.x,p.y);
      else if(p.type === 'rapid') drawGunUpgrade(p.x,p.y);
      else if(p.type === 'shield') drawShieldPickup(p.x,p.y);
    });

    // Bombs/explosions
    bombs.forEach(b=>drawExplosion(b));
    explosions.forEach(e=>drawExplosion(e));

    // Player HP
    drawHP(20,660,200,15,player.health);

    // HUD Metrics
    ctx.fillStyle = 'white';
    ctx.font = '16px Arial';
    ctx.fillText(`Score: ${score}`, 20, 30);
    ctx.fillText(`Time: ${survivalTime}s`, 20, 50);
    ctx.fillText(`Kills: ${kills}`, 20, 70);
    ctx.fillText(`Shots: ${shotsFired}`, 20, 90);
    const acc = shotsFired > 0 ? Math.round((hits / shotsFired) * 100) : 0;
    ctx.fillText(`Hit %: ${acc}%`, 20, 110);
    ctx.fillText(`Gun Lvl: ${gunLevel}`, 20, 130);

    // WIN overlay
    if(showWin){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,600,700);
      ctx.fillStyle = 'white';
      ctx.font = '48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('YOU WIN!', 300, 320);
      ctx.font = '18px Arial';
      ctx.fillText(`Score: ${score} — Time: ${survivalTime}s — Kills: ${kills}`, 300, 360);
      ctx.fillText('Refresh to play again', 300, 400);
      ctx.textAlign = 'left';
    }
  }

  // Draw pickups visually meaningful
  function drawHealthPickup(x,y){
    ctx.fillStyle = '#ff6666';
    ctx.fillRect(x+12, y+4, 6, 22);
    ctx.fillRect(x+4, y+12, 22, 6);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.strokeRect(x, y, 30, 30);
  }
  function drawGunUpgrade(x,y){
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(x+2, y+10, 20, 6);
    ctx.fillRect(x+20, y+12, 8, 2);
    ctx.fillStyle = '#444';
    ctx.fillRect(x+6, y+16, 6, 8);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.strokeRect(x, y, 30, 30);
  }
  function drawShieldPickup(x,y){
    ctx.fillStyle = '#66ffff';
    ctx.beginPath();
    ctx.moveTo(x+15, y+4);
    ctx.lineTo(x+26, y+10);
    ctx.lineTo(x+22, y+24);
    ctx.lineTo(x+8, y+24);
    ctx.lineTo(x+4, y+10);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.strokeRect(x, y, 30, 30);
  }

  function drawHP(x,y,w,h,p){
    ctx.strokeStyle='white'; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h);
    ctx.fillStyle=p>60?'lime':p>30?'yellow':'red'; ctx.fillRect(x,y,(p/100)*w,h);
  }
  function drawBossHP(x,y,w,h,current,max){
    ctx.strokeStyle='white'; ctx.strokeRect(x,y,w,h);
    const pct = Math.max(0, current) / max;
    ctx.fillStyle = pct > 0.6 ? '#66FF66' : pct > 0.3 ? '#FFFF66' : '#FF6666';
    ctx.fillRect(x,y,Math.floor(w * pct),h);
    ctx.fillStyle='white'; ctx.font='12px Arial'; ctx.fillText(`BOSS HP: ${Math.max(0,current)}/${max}`, x+8, y+13);
  }

  /********************** SCORING MULTIPLIER (accuracy) **********************/
  function getAccuracyMultiplier(){
    if(shotsFired === 0) return 1;
    const acc = hits / shotsFired;
    if(acc > 0.80) return 2.0;
    if(acc > 0.60) return 1.5;
    if(acc > 0.40) return 1.2;
    return 1.0;
  }

  /********************** END / OVERLAY **********************/
  function showEndOverlay(didWin){
    stopAmbience();
    const ctxLocal = ctx;
    ctxLocal.fillStyle = 'rgba(0,0,0,0.7)';
    ctxLocal.fillRect(0,0,600,700);
    ctxLocal.fillStyle = 'white';
    ctxLocal.font = '36px Arial';
    ctxLocal.textAlign = 'center';
    ctxLocal.fillText(didWin ? 'YOU WIN!' : 'GAME OVER', 300, 260);
    ctxLocal.font = '18px Arial';
    ctxLocal.fillText(`Score: ${score}`, 300, 300);
    ctxLocal.fillText(`Time survived: ${survivalTime}s`, 300, 330);
    ctxLocal.fillText(`Kills: ${kills} — Shots: ${shotsFired} — Hit%: ${shotsFired? Math.round((hits/shotsFired)*100):0}%`, 300, 360);
    ctxLocal.fillText('Press F5 to play again', 300, 420);
    ctxLocal.textAlign = 'left';
  }

  /********************** GAME LOOP **********************/
  function gameLoop(){ update(); render(); if(gameRunning) requestAnimationFrame(gameLoop); }

}); // end window.load
</script>

